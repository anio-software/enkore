import type {InternalSession} from "#~src/internal/InternalSession.d.mts"
import path from "node:path"
import {writeAtomicFile, isFileSync} from "@aniojs/node-fs"
import {createHash} from "node:crypto"
import {isAutogeneratedFile} from "#~src/internal/autogenerate/isAutogeneratedFile.mts"
import {getAutogeneratedFileHeader} from "#~src/internal/autogenerate/getAutogeneratedFileHeader.mts"

function hashString(str: string) {
	return createHash("sha256").update(str).digest("hex")
}

export async function createAutogeneratedFiles(
	session: InternalSession
) {
	for (const [_, file] of session.state.filesToAutogenerate.entries()) {
		const destinationPath = file.normalizedDestinationPath

		if (!destinationPath.startsWith("project/")) {
			throw new Error(`invalid destinationPath '${destinationPath}'.`)
		}

		const absoluteDestinationPath = path.join(
			session.projectRoot, destinationPath
		)

		//
		// make sure we don't overwrite a file that isn't autogenerated
		//
		if (isFileSync(absoluteDestinationPath)) {
			const destinationIsAutogenerated = await isAutogeneratedFile(
				absoluteDestinationPath
			)

			if (!destinationIsAutogenerated) {
				session.emitMessage(
					"error",
					"",
					`refusing to write to a file that is not marked as autogenerated.`
				)

				continue
			}
		}

		const code = await file.generator(
			session.publicAPI, destinationPath
		)

		file.output = code
		file.outputHash = hashString(code)

		session.emitMessage(
			"debug",
			`generating file '${destinationPath}'`
		)

		await writeAtomicFile(
			absoluteDestinationPath,
			getAutogeneratedFileHeader(
				path.basename(destinationPath)
			) + code,
			{
				createParents: true
			}
		)
	}
}

import type {InternalSession} from "#~src/internal/InternalSession.d.mts"
import type {FileToAutogenerate} from "#~src/internal/InternalSessionState.d.mts"
import path from "node:path"
import {writeAtomicFile, isFileSync} from "@aniojs/node-fs"
import {createHash} from "node:crypto"
import {isAutogeneratedFile} from "#~src/internal/autogenerate/isAutogeneratedFile.mts"
import {getAutogeneratedFileHeader} from "#~src/internal/autogenerate/getAutogeneratedFileHeader.mts"

function hashString(str: string) {
	return createHash("sha256").update(str).digest("hex")
}

type Ret = Pick<FileToAutogenerate, "output" | "outputHash"> | false

export async function createAutogeneratedFile(
	session: InternalSession,
	file: Omit<FileToAutogenerate, "output" | "outputHash">
): Promise<Ret> {
	const destinationPath = file.normalizedDestinationPath

	if (!destinationPath.startsWith("project/")) {
		throw new Error(`invalid destinationPath '${destinationPath}'.`)
	}

	const absoluteDestinationPath = path.join(
		session.projectRoot, destinationPath
	)

	//
	// make sure we don't overwrite a file that isn't autogenerated
	//
	if (isFileSync(absoluteDestinationPath)) {
		const destinationIsAutogenerated = await isAutogeneratedFile(
			absoluteDestinationPath
		)

		if (!destinationIsAutogenerated) {
			session.emitMessage(
				"error",
				"",
				`refusing to write to a file that is not marked as autogenerated.`
			)

			return false
		}
	}

	// make sure file is not tracked by git
	if (session.state.filesTrackedByGit.has(destinationPath)) {
		session.emitMessage(
			"error",
			"autogeneratedFileTrackedByGit",
			`please remove the file '${destinationPath}' (as its autogenerated) from git tracking.`
		)

		return false
	}

	const code = await file.generator(session.publicAPI, destinationPath)

	session.emitMessage("debug", `generating file '${destinationPath}'`)

	await writeAtomicFile(
		absoluteDestinationPath,
		getAutogeneratedFileHeader(
			path.basename(destinationPath)
		) + code,
		{
			createParents: true
		}
	)

	return {
		output: code,
		outputHash: hashString(code)
	}
}

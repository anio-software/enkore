import type {InternalSession} from "#~src/internal/InternalSession.d.mts"
import type {Autogenerate} from "#~synthetic/user/Steps.d.mts"
import {createAutogeneratedFiles} from "./createAutogeneratedFiles.mts"
import {scandir, writeAtomicFileJSON} from "@aniojs/node-fs"
import path from "node:path"
import preprocess from "../3.preprocess/index.mts"
import {readEnkoreLockFile} from "@enkore/common"
import {defineStepChecked} from "../defineStepChecked.mts"
import {updateGitIgnoreFile} from "./updateGitIgnoreFile.mts"
import {scandirEntryToEntityFactory} from "#~src/internal/scandirEntryToEntityFactory.mts"
import type {EnkoreProjectFile} from "@enkore/spec"

async function checkAutogeneratedFilesCI(
	session: InternalSession
) {
	const lockFileData = await readEnkoreLockFile(session.projectRoot)

	const sz1 = session.state.filesToAutogenerate.size
	const sz2 = Object.keys(lockFileData.autogeneratedFiles).length

	if (sz1 !== sz2) {
		throw new Error(
			`Expected number of hashes to match number of autogenerated files:\n\n` +
			`Expected number: ${sz1}\n` +
			`Actual number  : ${sz2}\n`
		)
	}

	for (const path in lockFileData.autogeneratedFiles) {
		const expectedHash = lockFileData.autogeneratedFiles[path].hash

		if (!session.state.filesToAutogenerate.has(path)) {
			throw new Error(
				`No hash entry for auto generated file '${path}'.`
			)
		}

		const actualHash = session.state.filesToAutogenerate.get(path)!.outputHash

		if (expectedHash !== actualHash) {
			throw new Error(
				`Hash mismatch`
			)
		}
	}
}

async function updateLockFile(session: InternalSession) {
	const lockFileData = await readEnkoreLockFile(session.projectRoot)

	lockFileData.autogeneratedFiles = {}

	for (const [key, value] of session.state.filesToAutogenerate.entries()) {
		lockFileData.autogeneratedFiles[key] = {
			hash: value.outputHash!
		}
	}

	await writeAtomicFileJSON(
		path.join(session.projectRoot, "enkore-lock.json"),
		lockFileData,
		{pretty: true}
	)
}

const executeStep: Autogenerate = async function(session) {
	await createAutogeneratedFiles(session)

	if (session.options.isCIEnvironment) {
		await checkAutogeneratedFilesCI(session)
	} else {
		await updateGitIgnoreFile(session)
		await updateLockFile(session)

		session.emitMessage("info", "update enkore-lock.json file")
	}

	const projectDirectoryEntries = await scandir(
		path.join(session.projectRoot, "project")
	)

	const scandirEntryToEntity = scandirEntryToEntityFactory(session.state)
	const allProjectFiles = projectDirectoryEntries.filter(entry => {
		//
		// ignore project root .gitignore file
		// because we are maintaining it from this package here
		//
		if (entry.relative_path === ".gitignore") return false

		return entry.type === "regularFile"
	}).map(scandirEntryToEntity)

	let filteredProjectFiles : EnkoreProjectFile[]  = []

	function markProjectFileAsFiltered(filePath: string) {
		for (const projectFile of allProjectFiles) {
			if (projectFile.absolutePath === filePath) {
				projectFile.wasFiltered = true

				return
			}
		}
	}

	if (typeof session.targetIntegrationAPI.projectSourceFileFilter === "function") {
		const filter = session.targetIntegrationAPI.projectSourceFileFilter
		const tmp : EnkoreProjectFile[]  = []

		for (const projectFile of allProjectFiles) {
			const keep = await filter(session.publicAPI, projectFile)

			if (!keep) {
				// i might have to change this in the future
				// dependening on the performance

				markProjectFileAsFiltered(projectFile.absolutePath)

				continue
			}

			tmp.push(projectFile)
		}

		filteredProjectFiles = tmp
	} else {
		filteredProjectFiles = allProjectFiles
	}

	session.state.projectDirectoryEntries = projectDirectoryEntries
	session.state.allProjectFiles = allProjectFiles
	session.state.filteredProjectFiles = filteredProjectFiles

	return {
		preprocess: async function() {
			return await preprocess.runStep(session)
		}
	}
}

export default defineStepChecked("autogenerate", executeStep)

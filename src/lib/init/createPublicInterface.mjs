import path from "node:path"

import {
	generateFromTemplate,
	generateSyncAsyncVariant
} from "../../autogenerate/index.mjs"

function parents(relative_path) {
	let parents = path.dirname(relative_path).split(path.sep)

	if (parents.length === 1 && parents[0] === ".") {
		return []
	}

	return parents
}

function createSyntheticScandirResult(project_root, files, sub_dir) {
	// normalize sub_dir and make sure it ends with a slash
	sub_dir = path.normalize(`${sub_dir}/`)

	return files.filter(file => {
		return file.relative_path.startsWith(sub_dir)
	}).map(file => {
		const relative_path = file.relative_path.slice(sub_dir.length)
		const absolute_path = path.join(
			project_root, sub_dir, relative_path
		)

/*
  {
    type: 'file',
    parents: [ 'something' ],
    name: 'Bla.mts',
    path: 'src/export/something/Bla.mts',
    relative_path: 'something/Bla.mts',
    absolute_path: '/Users/eXory2024/Desktop/github-new/anio-fs-org/api/src/export/something/Bla.mts'
  }
*/

		return {
			type: "file",
			parents: parents(relative_path),
			name: path.basename(relative_path),
			path: path.join(sub_dir, relative_path),
			relative_path,
			absolute_path
		}
	})
}

export default function(fourtune_session) {
	let public_interface = {
		getProjectRoot() {
			return fourtune_session.project.root
		},

		getProjectConfig() {
			return fourtune_session.project.config
		},

		addWarning(id, message) {
			fourtune_session.project.warnings.push({id, message})
		},

		autogenerate: {
			warningComment() {
				return `// Warning: this file was automatically created by fourtune vXXXXX
// You will find more information about the specific fourtune version used inside the file src/auto/VERSION.txt
// You should commit this file to source control\n`
			},

			//
			// returns the files that will be auto-generated by fourtune
			//
			getFiles() {
				return fourtune_session.files_to_autogenerate.map(entry => {
					return entry.relative_path
				})
			},

			//
			// return the files to be autogenerated in a format @anio-fs/scandir would return.
			//
			getFilesAsScandirResult(sub_dir = "src/auto") {
				return createSyntheticScandirResult(
					fourtune_session.project.root, fourtune_session.files_to_autogenerate, sub_dir
				)
			},

			generateFromTemplate,
			generateSyncAsyncVariant
		},

		distributables: {},

		//
		// used to hook into fourtune
		//
		hooks: {
			register(id, fn) {
				if (fourtune_session.target_hooks_locked) {
					throw new Error(
						`Cannot add hooks after target initialisation!`
					)
				}

				fourtune_session.target_hooks.push({id, fn})
			}
		},

		//
		// used for targets to set target specific data
		//
		target: {
			data: {}
		}
	}

	//
	// files that are added via this interace will be created in
	// "src/auto" folder. This is using the same internal API as the
	// "autogenerate" fourtune.config.mjs API.
	//
	// NB: functions that are used to generate autogenerated files
	// always return the source code as a string
	//
	public_interface.autogenerate.addFile = function addAutogeneratedFile(
		file_path, {generator, generator_args}
	) {
		const relative_path = path.join("src", "auto", file_path)
		const absolute_path = path.join(fourtune_session.project.root, relative_path)

		fourtune_session.files_to_autogenerate.push({
			relative_path,
			absolute_path,
			async generateFileSourceCode() {
				return await generator(public_interface, file_path, ...generator_args)
			}
		})
	}

	//
	//
	//
	public_interface.distributables.addFile = function addDistributionFile(
		file_path, {generator, generator_args}
	) {
		const relative_path = path.join("dist", file_path)
		const absolute_path = path.join(fourtune_session.project.root, relative_path)

		fourtune_session.distributables.push({
			relative_path,
			absolute_path,
			async generateDistributableFileContents() {
				return await generator(public_interface, file_path, ...generator_args)
			}
		})
	}

	return public_interface
}
